#include <assert.h>
#include <limits.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include <criterion/criterion.h>
#include <criterion/hooks.h>
#include <criterion/internal/ordered-set.h>

#ifdef _WIN32
#include <stdlib.h>
#define LF "\r\n"
#define NAME_MAX _MAX_FNAME
#else
#define LF "\n"
#endif

static const char *suitepat = "*";
static const char *testpat = "*";
static char runfn[NAME_MAX + 1] = { 0 };
static char listfn[NAME_MAX + 1] = { 0 };
static char stamp[64] = { 0 };

static const char
run_hdr[] =
    "<?xml version=\"1.0\" ?>" LF
    "<?xml-stylesheet type=\"text/xsl\" href=\"CUnit-Run.xsl\" ?>" LF
    "<!DOCTYPE CUNIT_TEST_RUN_REPORT SYSTEM \"CUnit-Run.dtd\">" LF
    "<CUNIT_TEST_RUN_REPORT>" LF
    "  <CUNIT_HEADER/>" LF;

/* TODO: Criterion version number not available */
static const char
run_ftr[] =
    "  <CUNIT_FOOTER> File Generated By Criterion - %s </CUNIT_FOOTER>" LF
    "</CUNIT_TEST_RUN_REPORT>";

static const char
run_result_hdr[] =
    "  <CUNIT_RESULT_LISTING>" LF;

static const char
run_result_ftr[] =
    "  </CUNIT_RESULT_LISTING>" LF;

static const char
run_suite_hdr[] =
    "    <CUNIT_RUN_SUITE>" LF
    "      <CUNIT_RUN_SUITE_SUCCESS>" LF
    "        <SUITE_NAME> %s </SUITE_NAME>" LF;

static const char
run_suite_ftr[] =
    "      </CUNIT_RUN_SUITE_SUCCESS>" LF
    "    </CUNIT_RUN_SUITE>" LF;

static const char
run_test_hdr[] =
    "        <CUNIT_RUN_TEST_RECORD>" LF;

static const char
run_test_ftr[] =
    "        </CUNIT_RUN_TEST_RECORD>" LF;

static const char
run_test_ok[] =
    "          <CUNIT_RUN_TEST_SUCCESS>" LF
    "            <TEST_NAME> %s </TEST_NAME>" LF
    "          </CUNIT_RUN_TEST_SUCCESS>" LF;

static const char
run_test_nok[] =
    "          <CUNIT_RUN_TEST_FAILURE>" LF
    "            <TEST_NAME> %s </TEST_NAME>" LF
    "            <FILE_NAME> %s </FILE_NAME>" LF
    "            <LINE_NUMBER> %u </LINE_NUMBER>" LF
    "            <CONDITION> %s </CONDITION>" LF
    "          </CUNIT_RUN_TEST_FAILURE>" LF;

static const char
run_stats[] =
    "  <CUNIT_RUN_SUMMARY>" LF
    "    <CUNIT_RUN_SUMMARY_RECORD>" LF
    "      <TYPE> Suites </TYPE>" LF
    "      <TOTAL> %zu </TOTAL>" LF
    "      <RUN> %zu </RUN>" LF
    "      <SUCCEEDED> - NA - </SUCCEEDED>" LF
    "      <FAILED> %zu </FAILED>" LF
    "      <INACTIVE> %zu </INACTIVE>" LF
    "    </CUNIT_RUN_SUMMARY_RECORD>" LF
    "    <CUNIT_RUN_SUMMARY_RECORD>" LF
    "      <TYPE> Test Cases </TYPE>" LF
    "      <TOTAL> %zu </TOTAL>" LF
    "      <RUN> %zu </RUN>" LF
    "      <SUCCEEDED> %zu </SUCCEEDED>" LF
    "      <FAILED> %zu </FAILED>" LF
    "      <INACTIVE> %zu </INACTIVE>" LF
    "    </CUNIT_RUN_SUMMARY_RECORD>" LF
    "    <CUNIT_RUN_SUMMARY_RECORD>" LF
    "      <TYPE> Assertions </TYPE>" LF
    "      <TOTAL> %zu </TOTAL>" LF
    "      <RUN> %zu </RUN>" LF
    "      <SUCCEEDED> %zu </SUCCEEDED>" LF
    "      <FAILED> %zu </FAILED>" LF
    "      <INACTIVE> n/a </INACTIVE>" LF
    "    </CUNIT_RUN_SUMMARY_RECORD>" LF
    "  </CUNIT_RUN_SUMMARY>" LF;

static const char
list_hdr[] =
    "<?xml version=\"1.0\" ?>" LF
    "<?xml-stylesheet type=\"text/xsl\" href=\"CUnit-List.xsl\" ?>" LF
    "<!DOCTYPE CUNIT_TEST_LIST_REPORT SYSTEM \"CUnit-List.dtd\">" LF
    "<CUNIT_TEST_LIST_REPORT>" LF
    "  <CUNIT_HEADER/>" LF;

/* TODO: Criterion version number not available */
static const char
list_ftr[] =
    "  <CUNIT_FOOTER> File Generated By Criterion - %s </CUNIT_FOOTER>" LF
    "</CUNIT_TEST_LIST_REPORT>";

static const char
list_stats[] =
    "  <CUNIT_LIST_TOTAL_SUMMARY>" LF
    "    <CUNIT_LIST_TOTAL_SUMMARY_RECORD>" LF
    "      <CUNIT_LIST_TOTAL_SUMMARY_RECORD_TEXT> Total Number of Suites </CUNIT_LIST_TOTAL_SUMMARY_RECORD_TEXT>" LF
    "      <CUNIT_LIST_TOTAL_SUMMARY_RECORD_VALUE> %zu </CUNIT_LIST_TOTAL_SUMMARY_RECORD_VALUE>" LF
    "    </CUNIT_LIST_TOTAL_SUMMARY_RECORD>" LF
    "    <CUNIT_LIST_TOTAL_SUMMARY_RECORD>" LF
    "      <CUNIT_LIST_TOTAL_SUMMARY_RECORD_TEXT> Total Number of Test Cases </CUNIT_LIST_TOTAL_SUMMARY_RECORD_TEXT>" LF
    "      <CUNIT_LIST_TOTAL_SUMMARY_RECORD_VALUE> %zu </CUNIT_LIST_TOTAL_SUMMARY_RECORD_VALUE>" LF
    "    </CUNIT_LIST_TOTAL_SUMMARY_RECORD>" LF
    "  </CUNIT_LIST_TOTAL_SUMMARY>" LF;

static const char
list_suites_hdr[] =
    "  <CUNIT_ALL_TEST_LISTING_SUITE>" LF;

static const char
list_suites_ftr[] =
    "  </CUNIT_ALL_TEST_LISTING_SUITE>" LF;

static const char
list_suite_hdr[] =
    "    <CUNIT_ALL_TEST_LISTING_SUITE>" LF
    "      <CUNIT_ALL_TEST_LISTING_SUITE_DEFINITION>" LF
    "        <SUITE_NAME> %s </SUITE_NAME>" LF
    "        <INITIALIZE_VALUE> %s </INITIALIZE_VALUE>" LF
    "        <CLEANUP_VALUE> %s </CLEANUP_VALUE>" LF
    "        <ACTIVE_VALUE> %s </ACTIVE_VALUE>" LF
    "        <TEST_COUNT_VALUE> %zu </TEST_COUNT_VALUE>" LF
    "      </CUNIT_ALL_TEST_LISTING_SUITE_DEFINITION>" LF
    "      <CUNIT_ALL_TEST_LISTING_SUITE_TESTS>" LF;

static const char
list_suite_ftr[] =
    "      </CUNIT_ALL_TEST_LISTING_SUITE_TESTS>" LF
    "    </CUNIT_ALL_TEST_LISTING_SUITE>" LF;

static const char
list_test[] =
    "        <TEST_CASE_DEFINITION>" LF
    "          <TEST_CASE_NAME> %s </TEST_CASE_NAME>" LF
    "          <TEST_ACTIVE_VALUE> %s </TEST_ACTIVE_VALUE>" LF
    "        </TEST_CASE_DEFINITION>" LF;

static void
print_run_test_stats(FILE *file, struct criterion_test_stats *stats)
{
    struct criterion_assert_stats *itr;

    (void)fprintf(file, run_test_hdr);
    if (stats->test_status == CR_STATUS_PASSED) {
        (void)fprintf(file, run_test_ok, stats->test->name);
    } else if (stats->test_status == CR_STATUS_FAILED) {
        for (itr = stats->asserts; itr != NULL; itr = itr->next) {
            if (!itr->passed) {
                (void)fprintf(
                    file,
                    run_test_nok,
                    stats->test->name,
                    itr->file,
                    itr->line,
                    itr->message);
                break;
            }
        }
    }
    (void)fprintf(file, run_test_ftr);
}

static void
print_run_suite_stats(FILE *file, struct criterion_suite_stats *stats)
{
    struct criterion_test_stats *itr;

    (void)fprintf(file, run_suite_hdr, stats->suite->name);
    for (itr = stats->tests; itr != NULL; itr = itr->next) {
        if (itr->test_status != CR_STATUS_SKIPPED) {
            print_run_test_stats(file, itr);
        }
    }
    (void)fprintf(file, run_suite_ftr);
}

static void
print_run_stats(FILE *file, struct criterion_global_stats *stats)
{
    size_t suites_failed = 0;
    size_t suites_passed = 0;
    struct criterion_suite_stats *itr;

    (void)fprintf(file, run_hdr);
    (void)fprintf(file, run_result_hdr);
    for (itr = stats->suites; itr != NULL; itr = itr->next) {
        if (itr->tests_skipped != itr->nb_tests) {
            print_run_suite_stats(file, itr);
            if (itr->tests_failed == itr->nb_tests) {
                suites_failed++;
            } else {
                suites_passed++;
            }
        }
    }
    (void)fprintf(file, run_result_ftr);
    (void)fprintf(
        file,
        run_stats,
        stats->nb_suites,
        suites_passed,
        suites_failed,
        (stats->nb_suites - (suites_passed - suites_failed)),
        stats->nb_tests,
        (stats->tests_passed + stats->tests_failed + stats->tests_crashed),
        stats->tests_passed,
        (stats->tests_failed + stats->tests_crashed),
        stats->tests_skipped,
        stats->nb_asserts,
        (stats->asserts_passed + stats->asserts_failed),
        stats->asserts_passed,
        stats->asserts_failed);
    (void)fprintf(file, run_ftr, stamp);
}

static void
print_list_test_stats(FILE *file, struct criterion_test_stats *stats)
{
    (void)fprintf(
        file,
        list_test,
        stats->test->name,
        (stats->test_status == CR_STATUS_SKIPPED ? "No" : "Yes"));
}

static void
print_list_suite_stats(FILE *file, struct criterion_suite_stats *stats)
{
    struct criterion_test_stats *itr;

    (void)fprintf(
        file,
        list_suite_hdr,
        stats->suite->name,
        "No", // <INITIALIZE_VALUE />
        "No", // <CLEANUP_VALUE />
        (stats->nb_tests == stats->tests_skipped ? "No" : "Yes"),
        stats->nb_tests);
    for (itr = stats->tests; itr != NULL; itr = itr->next) {
        print_list_test_stats(file, itr);
    }
    (void)fprintf(file, list_suite_ftr);
}

static void
print_list_stats(FILE *file, struct criterion_global_stats *stats)
{
    struct criterion_suite_stats *itr;

    (void)fprintf(file, list_hdr);
    (void)fprintf(file, list_stats, stats->nb_suites, stats->nb_tests);
    (void)fprintf(file, list_suites_hdr);

    for (itr = stats->suites; itr != NULL; itr = itr->next) {
        print_list_suite_stats(file, itr);
    }

    (void)fprintf(file, list_suites_ftr);
    (void)fprintf(file, list_ftr, stamp);
}

static int
patmatch(
    const char *pat,
    const char *str)
{
    while (*pat) {
        if (*pat == '?') {
            /* any character will do */
            if (*str++ == 0) {
                return 0;
            }
            pat++;
        } else if (*pat == '*') {
            /* collapse a sequence of wildcards, requiring as many
               characters in str as there are ?s in the sequence */
            while (*pat == '*' || *pat == '?') {
                if (*pat == '?' && *str++ == 0) {
                    return 0;
                }
                pat++;
            }
            /* try matching on all positions where str matches pat */
            while (*str) {
                if (*str == *pat && patmatch(pat+1, str+1)) {
                    return 1;
                }
                str++;
            }
            return *pat == 0;
        } else {
            /* only an exact match */
            if (*str++ != *pat++) {
                return 0;
            }
        }
    }

    return *str == 0;
}

ReportHook(POST_ALL)(struct criterion_global_stats *stats)
{
    FILE *runfh, *listfh;

    if (listfn[0] != '\0' && runfn[0] != '\0') {
        runfh = NULL;
        listfh = NULL;

        if ((runfh = fopen(runfn, "w")) != NULL &&
            (listfh = fopen(listfn, "w")) != NULL)
        {
            print_run_stats(runfh, stats);
            print_list_stats(listfh, stats);
        } else {
            (void)fprintf(stderr, "Cannot write results in CUnit format\n");
        }

        if (runfh != NULL) {
            (void)fclose(runfh);
        }
        if (listfh != NULL) {
            (void)fclose(listfh);
        }
    }
}

/* FIXME: Depending on internal knowledge is not very pretty, but it is the
          only way to provide a filter that will work on both *nix and non-*nix
          platforms. */
ReportHook(PRE_SUITE)(struct criterion_suite_set *set)
{
    struct criterion_ordered_set_node *itr;
    struct criterion_test *test;

    for (itr = set->tests->first; itr != NULL; itr = itr->next) {
        test = (struct criterion_test *)(itr + 1);
        if (!patmatch(suitepat, test->category) ||
            !patmatch(testpat, test->name))
        {
            fprintf(stderr, "disabled %s/%s\n", test->category, test->name);
            fprintf(stderr, "suitepat: %s, testpat: %s\n", suitepat, testpat);
            test->data->disabled = true;
        } else {
            fprintf(stderr, "enabled %s/%s\n", test->category, test->name);
        }
    }
}

int
main(int argc, char *argv[])
{
    int result = 0;
    int argno, cr_argc, sz;
    char *pfx, **cr_argv;
    const char runfmt[] = "%s-Results.xml";
    const char listfmt[] = "%s-Listing.xml";
    const char stampfmt[] = "%a %b %e %H:%M:%S %Y";
    time_t now;

    /* Before handing over argc and argv over to criterion, go over the list to
       extract the custom options. Note that these are meant to be "hidden" */
    cr_argc = 0;
    if ((cr_argv = calloc(argc, sizeof(*cr_argv))) == NULL) {
        result = 1;
    } else {
        for (argno = 0; argno < argc; argno++) {
            /* FIXME:
               Eventually CUnit output format should be supported through an
               actual logger implementation, but it will do for now.
               See: http://criterion.readthedocs.io/en/master/output.html */
            if (strncmp(argv[argno], "--cunit", 7) == 0) {
                if ((pfx = strchr(argv[argno], '=')) != NULL) {
                    pfx++;
                } else {
                    pfx = "CriterionAutomated";
                }

                sz = snprintf(runfn, sizeof(runfn), runfmt, pfx);
                assert(sz > 0 && sz < sizeof(runfn));
                sz = snprintf(listfn, sizeof(listfn), listfmt, pfx);
                assert(sz > 0 && sz < sizeof(listfn));
                now = time(NULL);
                sz = (int)strftime(
                    stamp, sizeof(stamp), stampfmt, localtime(&now));
                assert(sz != 0);
            } else if (strncmp(argv[argno], "--suite", 7) == 0) {
                if ((argno + 1) == argc) {
                    fprintf(stderr, "--suite requires an argument\n");
                    result = 1;
                    goto bail;
                }
                suitepat = (const char *)argv[++argno];
            } else if (strncmp(argv[argno], "--test", 6) == 0) {
                if ((argno + 1) == argc) {
                    fprintf(stderr, "--test requires an argument\n");
                    result = 1;
                    goto bail;
                }
                testpat = (const char *)argv[++argno];
            } else {
                cr_argv[cr_argc++] = argv[argno];
            }
        }

        struct criterion_test_set *tests = criterion_initialize();

        if (criterion_handle_args(cr_argc, cr_argv, true)) {
            result = !criterion_run_all_tests(tests);
        }

        criterion_finalize(tests);

bail:
        free(cr_argv);
    }

    return result;
}
